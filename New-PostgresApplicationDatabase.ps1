#! /usr/bin/env pwsh
<#
  .SYNOPSIS
  Create a Postgres application database and roles for owner, application, and application_readonly
  
   .DESCRIPTION
  Create a Postgres application database and create roles for owner, application, and application_readonly.
  
  - the owner role has no login. the user that runs this script will be assigned to that role
  - the application and application_readonly roles will be login roles with password either specified by you
    or generated by this script. 
  - If the passwords are generated by this script, they will be printed as the first 
    2 lines of output of this script. 
  - If the script scram_postgres_password.py exists in the path, the passwords will be scram encrypted.

  - Optionally install common extensions UUID, plv8 and trigram
  - Optionally create functions for view and drop database connections
   
  .LINK
  https://gist.github.com/chrisfcarroll/ed3f8c368ad6bdbbe8a71d4c3afa48f7
  
  .LINK
  For Scram encryption (requires python3): https://gist.github.com/chrisfcarroll/4c819af67ec5485ed0d6aef7863562a4
#>

Param(
  $databaseName="APPNAME",
  $postgresHost="localhost",
  [string]$databaseOwner,
  $appAccount,
  [string]$appAccountPassword,
  $readonlyAppAccount,
  [string]$readonlyAppAccountPassword,
  $dbEncoding='UTF-8',
  $dbLocale,
  [switch]$createViewAndDropConnectionFunctions,
  [switch]$addPlv8,
  [switch]$addTrigram,
  [bool]$addUUID=$true,
  [string]$adminUser=[Environment]::UserName,
  [switch]$dryRun,
  [switch]$down
)

function defaultLocaleForLocalhost{
  $nixenUK='en_GB'
  $windowsenUK="English_United Kingdom"
  $nixenUS="en_US"
  $windowsenUS="English_United States"
  $lc= if($IsWindows){$windowsenUK}else{$nixenUK}
  return $lc
}
if(-not $dbLocale){$dbLocale= defaultLocaleForLocalhost}

function runOrDryRun($command, $db, [switch]$onErrorStop){
  if($dryRun){ "-d $db :  $command" }
  else{
    $command | psql -v ON_ERROR_STOP=$(if($onErrorStop){1}else{0}) -X --echo-all `
          --host=$postgresHost -d $db -U $adminUser
    return $?
  }
}

function sanitiseAndValidateParametersElseForceDryRun{

  $script:appAccount= [string]::IsNullOrWhiteSpace( $appAccount ) ? $databaseName : $appAccount
  $script:readonlyAppAccount= [string]::IsNullOrWhiteSpace( $readonlyAppAccount ) ? $databaseName+"_readonly" : $readonlyAppAccount
  $script:databaseOwner= [string]::IsNullOrWhiteSpace( $databaseOwner ) ? $databaseName+"_owner" : $databaseOwner  
  
  $invalid= ('$postgresHost','$databaseName','$dbLocale','$dbEncoding','$databaseOwner',
             '$appAccount','$readonlyAppAccount','$adminUser'
             ).Where( {-not (Invoke-Expression $_)})
  if($invalid.Count){
    $script:dryRun.IsPresent=$true
    write-warning "dry running because you missed a parameter: $invalid"
  }
}
sanitiseAndValidateParametersElseForceDryRun

function New-Password([int]$length=12){ 
  1..($length * 3) |
          ForEach-Object{ Get-Random -Minimum 48 -Maximum 122 } |
          Where-Object { $_ -lt 58 -or $_ -gt 64 } | Where-Object {$_ -lt 91 -or $_ -gt 96 } |
          ForEach-Object{ [Char]$_ } | Select-Object -first $length | 
          ForEach-Object {$agg=""} {$agg += $_} {$agg} 
}

function Up{

  if(-not $appAccountPassword){
    $appAccountPassword= New-Password 20
    $appAccountPassword
    $didGeneratePassword=$true
  }
  if(-not $readonlyAppAccountPassword){
    $readonlyAppAccountPassword= New-Password 20
    $readonlyAppAccountPassword
    $didGeneratePassword=$true
  }

  if($didGeneratePassword)
  {
    write-warning "-----------------------------------------------------
You did not provide passwords, so passwords were created and shown above this line."
  }

  if(get-command scram_postgres_password.py){
    $canScramEncrypt=$true
    $appAccountPassword= scram_postgres_password.py $appAccount $appAccountPassword
    $readonlyAppAccountPassword=scram_postgres_password.py $readonlyAppAccount $readonlyAppAccountPassword
  }
  elseif (Get-Command md5)
  {
    $appAccountPassword= "md5" + $(md5 ($appAccountPassword + $appAccount))
    $readonlyAppAccountPassword = "md5" + $(md5 ($readonlyAppAccountPassword + $readonlyAppAccount))
  }

  "
-----------------------------------------------------
  Will log in to Host=$postgresHost as User=$adminUser to create:
  
    Database= $databaseName 
    with
    database Owner=$databaseOwner
    Locale=$dbLocale
    application Login=$appAccount
    application readonly login=$readonlyAppAccount
    add UUID extension: $addUUID
    add Trigram extension: $addTrigram
    add plv8 extension: $addPlv8
    Create Functions for View and Drop Connections: $createViewAndDropConnectionFunctions
    Passwords generate by: $(if($didGeneratePassword){"This script"}else{"You"})
  $(if($canScramEncrypt){"Passwords will be stored as scram-hashes"})
  "

  "
-----------------------------------------------------

starting ...
"

  $requireds= ('$postgresHost','$databaseName','$dbLocale','$databaseOwner','$appAccount','$readonlyAppAccount',
  '$appAccountPassword','$readonlyAppAccountPassword')
  $invalids= $requireds | Where-Object { -not $ExecutionContext.InvokeCommand.ExpandString($_) }

  if($invalid.Count){
    $dryRun=$true
    write-warning "dry running because you missed a parameter: $([string]::Join(", ", $invalids))"
  }


  runOrDryRun @"
  Create Role $databaseOwner CreateDb CreateRole ;
  Grant $databaseOwner to current_user ;
  CREATE DATABASE $databaseName With Owner $databaseOwner TEMPLATE = template0 $dbLocale ;
  Alter Database $databaseName set client_encoding='UTF8' ;
  Create Role $appAccount Login Password `'$appAccountPassword`' ;
  Create Role $readonlyAppAccount Login Password `'$readonlyAppAccountPassword`' ;
  Grant Connect , Temporary on Database $databaseName TO $appAccount ;
  Grant Connect , Temporary on Database $databaseName TO $readonlyAppAccount ;
  Grant $readonlyAppAccount to $appAccount;
  Grant $appAccount to $databaseOwner;
  Revoke Connect On Database $databaseName From Public;
"@  'postgres'
  
  
  if($createViewAndDropConnectionFunctions)
  {
    "    Adding favourite Utilities to database postgres ..."
    
    runOrDryRun @"
  Create or Replace Function ps() 
    Returns Table (pid int, datname name, usename name, application_name text, client_addr inet) 
    Language SQL 
    As 'Select a.pid, a.datname, a.usename, a.application_name, a.client_addr from pg_stat_activity a' ;
  
  Create or Replace Function DropConnections(id int, database name)
    Returns Void
    Language PlpgSQL
    As `$`$
    Begin
      If (id is null and database is null ) Then Raise 'At least one of id or database must be not-null' ; End If;
      Perform pg_terminate_backend(pg_stat_activity.pid)
      FROM pg_stat_activity
      WHERE ( pg_stat_activity.datname = database Or database is null)
        AND ( pid = id or id is null);
    End `$`$;
"@ 'postgres'
  }
  
  if($addUUID){
    "    Adding extension uuid-ossp to database lb ..."
    runOrDryRun 'Create Extension If Not Exists "uuid-ossp" ;' $databaseName
  }
  
  if($addTrigram){
    "    Adding extension pg_trgm to database lb ..."
    runOrDryRun 'Create Extension If Not Exists "pg_trgm" ;' $databaseName
  }
  
  if($addPlv8){
    "    Adding extension plv8 to database lb ..."
    runOrDryRun 'Create Extension If Not Exists "plv8" ;' $databaseName
    
      if(-not $?){
        write-warning "Create Extension plv8 failed. Trying to first install to db=postgres"
        'Create Extension If Not Exists "plv8" ;' | psql --host=$postgresHost -d postgres -U $adminUser -X --echo-all
        'Create Extension If Not Exists "plv8" ;' | psql --host=$postgresHost -d lb -U $adminUser -X --echo-all
    
        if(-not $?){
          write-warning "Create Extension plv8 failed. Trying to install plv8 to your postgres instance"
          start -verb runas powershell "$PSScriptRoot/install-postgres-plv8-extension.ps1"
          write-error "rerun this script after the server has restarted."
          exit 1
        }
      }
  }
}

function Down{

  "
-----------------------------------------------------
  Will log in to Host=$postgresHost as User=$adminUser to Drop Database and Roles:
  
    database Owner=$databaseOwner
    Application Login=$appAccount
    Application Readonly Login=$readonlyAppAccount

-----------------------------------------------------

starting ...
"

  $requireds= ('$postgresHost','$databaseName','$databaseOwner','$appAccount','$readonlyAppAccount')
  $invalids= $requireds | Where-Object { -not $ExecutionContext.InvokeCommand.ExpandString($_) }

  if($invalid.Count){
    $dryRun=$true
    write-warning "dry running because you missed a parameter: $([string]::Join(", ", $invalids))"
  }

  if(runOrDryRun @"
\set ON_ERROR_STOP on
    Do `$`$
    Begin
    If Exists (select * from information_schema.tables 
            where table_schema not in ('pg_catalog','information_schema')) Then
        Raise Exception 'Aborted Drop database and roles because tables have been created. First Drop the Tables' ;
    Else
        Raise Notice 'This script will drop the ROLES created but cannot drop the DATABASE. You must do that 
        manually.';
    End If;
    End `$`$     
"@  $databaseName){
    runOrDryRun @"
    Revoke all On Database $databaseName from $appAccount ;
    Revoke all On Database $databaseName from $readonlyAppAccount ;
    Alter Database $databaseName Owner to $adminUser ; 
    Drop role $appAccount ;
    Drop role $readonlyAppAccount ;
    Drop role $databaseOwner ;
    Drop Database $databaseName;    
"@ 'postgres'
  }
}

if($down){Down}else{Up}