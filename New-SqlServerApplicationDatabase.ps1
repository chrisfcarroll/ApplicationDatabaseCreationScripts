#! /usr/bin/env pwsh

<#
  .SYNOPSIS
  Create an MS SQL Server application database and roles for application and application_readonly,
  and alter authorization to an applicationdatabaseowner account
  
   .DESCRIPTION
  Create an MS SQL Server application database and roles for application and application_readonly, 
  and alter authorization to an applicationdatabaseowner account.
  
  - the application and application_readonly roles will be login roles with password either 
    specified by you or generated by this script. 
  - If the passwords are generated by this script, they will be printed as the first 2 lines
    of output of this script. 
   
  .LINK
  https://github.com/chrisfcarroll/ApplicationDatabases

#>
Param(
  ##A name for the new database
  [string][ValidatePattern('(".+"|[^"]+)')]$databaseName="appname",

  ##The MS SQL Server Instance you wish to target. See SQLCmd help for possible formats, which is currently: [protocol:]server[\instance_name][,port]
  ##Defaults to $env:SQLCMDSERVER if set, or "." if not
  [string][Alias('S')]$serverInstance=  $env:SQLCMDSERVER ?? ".",

  ##The Login that can run this script. This login must have Alter Any Login and Create Any Database permissions 
  ##on the server. Defaults to $env:SQLCMDUSER if set.
  [string][Alias('U')]$ciLogin= $env:SQLCMDUSER,

  ##The password for -ciLogin. Defaults to $env:SQLCMDPASSWORD if that has been set.
  [string][Alias('P')]$ciLoginPassword= $env:SQLCMDPASSWORD,

  ##The name of the Login to Create having read & write access to the new database. Defaults
  ##to the same as -databaseName
  [string]$appLogin,
  
  ##The password to use for -appLogin. If not is given, one will be generated and displayed as the
  ##first line of output of this script.
  [string]$appLoginPassword,
  
  ##The name of the Login to Create having read access to the new database. Defaults to <databaseName>_readonly
  [string]$readonlyAppLogin,
  
  ##The password to use for -readonlyAppLogin. If none is given, one will be generated and displayed as the
  ##second or first line of output of this script.
  [string]$readonlyAppLoginPassword,
  
  ##Leave this blank to use the server default language for the new logins
  [string]$loginLanguage,

  ## Leave this blank to use the server default collation for the new database
  [string]$collation,

  ##If set, the SQL scripts will be echoed but not run
  [switch]$dryRun,

  ##Shows help, then stop.
  [switch]$help,

  ##Shows full help, then stop.
  [switch]$helpFull,

  ##If set, this Login will be made the owner of the newly created database. If blank, the new database will
  ##remain owned by -ciLogin.
  ## - The Login must already exist, and -ciLogin must have Impersonate Permisson on it.
  ## - Creating the databaseOwner Login must be done once-per server to create it, run this script once 
  ##   interactively with -bootstrapSysAdminLogin='<sysadminlogin>'
  ##
  ##See https://docs.microsoft.com/en-us/sql/t-sql/statements/alter-authorization-transact-sql#best-practice
  ##on the idea of using a Disabled Login as the database Owner. 
  [string]$databaseOwner='ApplicationDatabaseOwner',
  
  ##A sysadmin login that can bootstrap the -databaseOwner Login. Run this once per server to create a 
  ## databaseOwner Login, which will be disabled, and which can be used as an owner for application databases.
  [string]$bootstrapSysAdminLogin,

  ## Delete the Database and the associated Roles
  [switch][Alias("Down")]$deleteDatabaseAndRoles
)

function sqlcmdGet($query, $db, [switch]$onErrorStop){
  $r=(sqlcmd -S $serverInstance -d $db -U $ciLogin -P $ciLoginPassword -e -X -Q $query)
  if(-not $r -or $r[1] -match "Msg \d+, Level \d+, State \d+") 
    {throw "SQL command failed on server $serverInstance database $db : $query"}
  return $r
}
function getSQLScalar($query, $db, [switch]$onErrorStop){
  $r=(sqlcmdGet @PSBoundParameters)
  return ($r.Length -and $r.Length -gt 2) ? $r[3] : $r
}

function runOrDryRun($command, $db, [switch]$onErrorStop, $login=$ciLogin, $password=$ciLoginPassword){
  if($dryRun){ "-d $db :`n$command" }
  else{
    $r=(sqlcmd -S $serverInstance -d $db -U $login -P $Password -e -X -j -Q $command)
    return $? ? $r : $?
  }
}

if($helpFull){ Get-Help $PSCommandPath ; Get-Help $PSCommandPath -Parameter '*' ; Exit }
if($help){ Get-Help $PSCommandPath ; Exit}

function isQuoted([string]$str){return $str -like '`[*`]'}
function quote([string]$str){return ((isQuoted $str) ? $str : '['+$str+']') }
function unQuote([string]$str){return ((isQuoted $str) ? $str.Substring(1,$str.Length-2) : $str) }
$validTSqlIdentifier='^[_\p{Ll}][_\p{Ll}\p{Mn}\d]*$'

function isValidTSqlIdentifier([string]$str){return ($str -cmatch $validTSqlIdentifier) -or ($str -like '`[*`]') }

function qadd([string]$left,[string]$right,$quotemark='"'){
  $isQl=(isQuoted $left)
  $isQr=(isQuoted $right)
  $l= $isQl ? $left.Substring(1,$left.Length-2)   : $left
  $r= $isQr ? $right.Substring(1,$right.Length-2) : $right
  $a= ($isQl -or $isQr) ? (quote ($l + $r) ) : ($l + $r)
  return $a
}

function sanitiseAndAutocompleteParameters{
  if(-not (isValidTSqlIdentifier $databaseName)){
      throw "$databaseName is not a valid database name. Either surround it in with [square brackets] or use a different name."
  }
  $script:databaseOwner= [string]::IsNullOrWhiteSpace( $databaseOwner ) ? (qadd $databaseName "_owner") : $databaseOwner.ToLower()
  $script:appLogin= [string]::IsNullOrWhiteSpace( $appLogin ) ? $databaseName : $appLogin.ToLower()
  $script:readonlyAppLogin= [string]::IsNullOrWhiteSpace( $readonlyAppLogin ) ? (qadd $databaseName "_readonly") : $readonlyAppLogin.ToLower()
}
function validateUpParametersElseForceDryRun{

  $requireds= '$serverInstance','$databaseName','$databaseOwner','$appLogin','$readonlyAppLogin'
  $invalid= $requireds.Where( {-not (Invoke-Expression $_)})
  if($invalid.Count){
    $script:dryRun=$true
    write-warning "dry running because you missed a parameter: $invalid"
  }

  $identifiers= '$databaseName','$databaseOwner','$appLogin','$readonlyAppLogin'
  $invalid= $identifiers.Where( {-not (isValidTSqlIdentifier (Invoke-Expression $_))})
  if($invalid.Count){
    $script:dryRun=$true
    write-warning "dry running because some parameters are not valid identifiers: $invalid"
    write-warning "NB to supply a quoted string in powershell,bash,etc you must quote the quotes, e.g.:  `'`"Quoted Name!`"`' "
  }
}
function validateDownParametersElseForceDryRun{
  $requireds= ('$serverInstance','$databaseName','$databaseOwner','$appLogin','$readonlyAppLogin')
  $invalids= $requireds | Where-Object { -not (Invoke-Expression $_) }

  if($invalid.Count){
    $script:dryRun=$true
    write-warning "dry running because you missed a parameter: $([string]::Join(", ", $invalids))"
  }
}
sanitiseAndAutocompleteParameters
if($deleteDatabaseAndRoles){validateDownParametersElseForceDryRun}else{validateUpParametersElseForceDryRun}

function New-Password([int]$length=12){ 
  1..($length * 3) |
          ForEach-Object{ Get-Random -Minimum 48 -Maximum 122 } |
          Where-Object { $_ -lt 58 -or $_ -gt 64 } | Where-Object {$_ -lt 91 -or $_ -gt 96 } |
          ForEach-Object{ [Char]$_ } | Select-Object -first $length | 
          ForEach-Object {$agg=""} {$agg += $_} {$agg} 
}

function bootstrapDatabaseOwnerAndCILogin{
  $bootstrap=@"
    Use Master
    If Not Exists (Select * from syslogins where name = '$ciLogin')
        RaisError ('NOTE the ci Login does not yet exist', 1,1)

    Create Login ApplicationDatabaseOwner With Password = '$(New-Password 20)'
    Alter Login Applicationdatabaseowner Disable

    Grant Impersonate On Login::Applicationdatabaseowner To $ciLogin
    Grant Alter Any Login To $ciLogin
    Grant Create Any Database To $ciLogin
"@

  if($dryRun){ "Bootstrap Logins for ApplicationDatabaseOwner and ci. 
                This script must be run once with a sysadmin login.:`n$bootstrap" }
  else{
    sqlcmd -S $serverInstance -d master -U $bootstrapSysAdminLogin -e -X -j -Q $bootstrap
  }
}

function doesDatabaseOwnerExist{
  $count=(getSQLScalar "Select Count(*) from master.dbo.syslogins Where name=`'$databaseOwner`'" "master")
  $itExists= (1 -eq  [int]$count)
  return $itExists
}

function Up{

  if(-not $appLoginPassword){
    $appLoginPassword= New-Password 20
    $appLoginPassword
    $didGeneratePassword=$true
  }
  if(-not $readonlyAppLoginPassword){
    $readonlyAppLoginPassword= New-Password 20
    $readonlyAppLoginPassword
    $didGeneratePassword=$true
  }

  if($didGeneratePassword)
  {
    write-warning "-----------------------------------------------------
You did not provide passwords, so passwords were generated with Get-Random and shown above this line."
  }

  if($databaseOwner -and -not (doesDatabaseOwnerExist))
  {
    Write-Warning "
    You specified databaseOwner $databaseOwner but that login does not exist on the server.
    First, run this script interactively with the -bootstrapSysAdminLogin set to a sysadmin login to
    create the databaseOwner role and to Grant Impersonate on it to the $ciLogin.
    "
    throw "databaseOwner Login $databaseOwner does not exist on server $serverInstance."
  }

  $collationClause= ($collation) ? "With COLLATE $collation" : ""
  $languageClause= ($loginLanguage) ? ", Default_Language=$loginLanguage" : ""
  if($databaseOwner){
    $databaseOwnerLine= "Alter Authorization ON database::$databaseName TO $databaseOwner ;"
    $executeAs= "Execute As Login=`'$databaseOwner`'
GO
"
  }
  "
-----------------------------------------------------
  Will log in to Server=$serverInstance as User $($ciLogin ?? "(Integrated Security)") to create:
  
    Database=$databaseName $collationClause
    with
    database Owner=$(($databaseOwner) ? $databaseOwner : $ciLogin)
    application Login=$appLogin $languageClause
    application readonly login=$readonlyAppLogin $languageClause
    Passwords generate by: $(if($didGeneratePassword){"This script"}else{"You"})
-----------------------------------------------------

starting ...
"
 
  runOrDryRun @"
    CREATE DATABASE $databaseName $collationClause ;
    Create Login $appLogin With Password = `'$appLoginPassword`' $languageClause 
                 , Default_Database=$databaseName ;
    Create Login $readonlyAppLogin With Password =`'$readonlyAppLoginPassword`' $languageClause 
                 , Default_Database=$databaseName ;
    $databaseOwnerLine
"@  'master'

  runOrDryRun @"
    $executeAs

    Use $databaseName

    Create User $appLogin For Login $appLogin With Default_Schema=dbo;
    Create User $readonlyAppLogin For Login $readonlyAppLogin With Default_Schema=dbo;
    Create User $ciLogin For Login $ciLogin With Default_Schema=dbo;
    Alter Role db_owner Add Member $ciLogin ;
    Alter Role db_datareader Add Member $appLogin ;
    Alter Role db_datawriter Add Member $appLogin ;
    Alter Role db_datareader Add Member $readonlyAppLogin ;
"@  'master'

}

function Down{

  "-----------------------------------------------------
  Will log in to Server=$serverInstance as User $($ciLogin ?? "(Integrated Security)") to Drop Database and Logins:
    
      database Owner=$databaseOwner
      Application Login=$appLogin
      Application Readonly Login=$readonlyAppLogin

  -----------------------------------------------------

  starting ...
"
$executeAs= ($databaseOwner) ? "Execute As Login=`'$databaseOwner`'
GO
" : ""

  $dbExists=[int](getSQLScalar "Select Count(*) from master..sysdatabases where name = `'$databaseName`'" "master")
  if($dbExists){
    $tablesExistQ=(getSQLScalar "$executeAs Select Count(*) from $databaseName.information_schema.tables" "master")
    $tablesExist= [int]$tablesExistQ -gt 0
  }
  if ($dbExists -and $tablesExist)
  {
    write-warning "Aborted Drop Database $databaseName and Logins because tables have been created. First Drop the Tables."
  }
  else
  {
    runOrDryRun @"
      If Exists (Select * from master..syslogins where name='$appLogin') 
         Drop Login $appLogin
         Else Begin Print 'Login $appLogin already gone.' End;
      If Exists (Select * from master..syslogins where name='$readonlyAppLogin')
         Drop Login $readonlyAppLogin
         Else Begin Print 'Login $readonlyAppLogin already gone.' End ;

      $executeAs
      If Exists (Select * from master..sysdatabases where name='$databaseName')
        Drop Database $databaseName
        Else Begin Print 'Database $databaseName already gone.' End;
"@ 'master'
  }
}

if($bootstrapSysAdminLogin)
{
  bootstrapDatabaseOwnerAndCILogin
}
elseif($deleteDatabaseAndRoles)
{
  Down
}
else
{
  Up
}